//-----------------------------------------------------
// ProjectName: Drac
// Function   : Monitor events generated by SoC
// Description: The PMU is an AXI peripheral that allow to monitor several
//              events, you can set how many you need with N_COUNTERS.
//              The amount of Counters and configuration registers affect the
//              IO space adress in the processor, so be sure that the driver
//              library writtes in the correspoding address.
//              axi_awaddr[1:0] and axi_araddr[1:0] are unused because data 
//              is accessed must be 32bit aligned.
// Coder      : G.Cabo
// References : Implementation of Maximum-Contention Control Unit (MCCU): 
//              ResourceAccess Count and Contention Time Enforcement. 
//              https://upcommons.upc.edu/handle/2117/133656

`default_nettype none
`timescale 1 ns / 1 ps

`ifndef SYNT
    `ifdef FORMAL 
        `define ASSERTIONS
    `endif
`endif
	module AXI_PMU_interface_v1_0_S00_AXI #
	(
		// Width of S_AXI data bus
		parameter integer C_S_AXI_DATA_WIDTH	= 32,
		// Width of S_AXI address bus
		parameter integer C_S_AXI_ADDR_WIDTH	= 7,
		// Amount of counters
		parameter integer N_COUNTERS	= 9,
		// Configuration registers
		parameter integer N_CONF_REGS	= 1,
		// Overflow
		parameter integer OVERFLOW	= 1, //Yes/No
		// Quota
		parameter integer QUOTA	= 1, //Yes/No
		// MCCU - Maximum-contention Control Unit mode
		parameter integer MCCU	= 1, //Yes/No
		// MCCU - N_CORES
		parameter integer N_CORES	= 1 
	)
	(
        //interruptions risen when one event exceeds it expected max duration
        output wire int_rdc_o,
        //interruptions risen when cores exceeds the quota of MCCU
        output wire MCCU_int_o [N_CORES-1:0],
        //interruption rises when one of the counters overflows
        output reg int_overflow_o,
        //interruption rises when the total of cuota consumed is exceeded
        output wire int_quota_o,
        //external signals from Soc events
        input wire [N_COUNTERS-1:0] events_i, // bus of signals for counters 
		// Global Clock Signal
		input wire  S_AXI_ACLK_i,
		// Global Reset Signal. This Signal is Active LOW
		input wire  S_AXI_ARESETN_i,
		// Write address (issued by master, acceped by Slave)
		input wire [C_S_AXI_ADDR_WIDTH-1 : 0] S_AXI_AWADDR_i,
		// Write address valid. This signal indicates that the master signaling
    		// valid write address and control information.
		input wire  S_AXI_AWVALID_i,
		// Write address ready. This signal indicates that the slave is ready
    		// to accept an address and associated control signals.
		output wire  S_AXI_AWREADY_o,
		// Write data (issued by master, acceped by Slave) 
		input wire [C_S_AXI_DATA_WIDTH-1 : 0] S_AXI_WDATA_i,
		// Write strobes. This signal indicates which byte lanes hold
    		// valid data. There is one write strobe bit for each eight
    		// bits of the write data bus.    
		input wire [(C_S_AXI_DATA_WIDTH/8)-1 : 0] S_AXI_WSTRB_i,
		// Write valid. This signal indicates that valid write
    		// data and strobes are available.
		input wire  S_AXI_WVALID_i,
		// Write ready. This signal indicates that the slave
    		// can accept the write data.
		output wire  S_AXI_WREADY_o,
		// Write response. This signal indicates the status
    		// of the write transaction.
		output wire [1 : 0] S_AXI_BRESP_o,
		// Write response valid. This signal indicates that the channel
    		// is signaling a valid write response.
		output wire  S_AXI_BVALID_o,
		// Response ready. This signal indicates that the master
    		// can accept a write response.
		input wire  S_AXI_BREADY_i,
		// Read address (issued by master, acceped by Slave)
		input wire [C_S_AXI_ADDR_WIDTH-1 : 0] S_AXI_ARADDR_i,
		// Read address valid. This signal indicates that the channel
    		// is signaling valid read address and control information.
		input wire  S_AXI_ARVALID_i,
		// Read address ready. This signal indicates that the slave is
    		// ready to accept an address and associated control signals.
		output wire  S_AXI_ARREADY_o,
		// Read data (issued by slave)
		output wire [C_S_AXI_DATA_WIDTH-1 : 0] S_AXI_RDATA_o,
		// Read response. This signal indicates the status of the
    		// read transfer.
		output wire [1 : 0] S_AXI_RRESP_o,
		// Read valid. This signal indicates that the channel is
    		// signaling the required read data.
		output wire  S_AXI_RVALID_o,
		// Read ready. This signal indicates that the master can
    		// accept the read data and response information.
		input wire  S_AXI_RREADY_i
	);
//----------------------------------------------
//-------------AXI and PMU local paramaters
//----------------------------------------------
	localparam integer ADDR_LSB = (C_S_AXI_DATA_WIDTH/32) + 1;
	localparam integer OPT_MEM_ADDR_BITS = 4;
    
    //One bit per counter and round up to N registers of DATA_WIDTH
    localparam integer N_OVERFLOW_REGS= (OVERFLOW == 0)? 0
                       :(N_COUNTERS % C_S_AXI_DATA_WIDTH) >0
                       ? (N_COUNTERS / C_S_AXI_DATA_WIDTH)+1 
                       : (N_COUNTERS / C_S_AXI_DATA_WIDTH);

    localparam integer N_QUOTA_MASK= (QUOTA==1)
                       ?(N_COUNTERS/C_S_AXI_DATA_WIDTH)+1:0;

    localparam integer N_QUOTA_LIMIT= (QUOTA==1)?1:0;//quota_limit
    

    //if more than 32 counters extra registers are needed for overflow
    localparam integer BASE_QUOTA = N_COUNTERS + N_CONF_REGS + N_OVERFLOW_REGS;
    //First addres for the MCCU
    localparam integer BASE_MCCU = BASE_QUOTA + N_QUOTA_MASK + N_QUOTA_LIMIT;
//----------------------------------------------
//-------------MCCU local paramaters
//----------------------------------------------
    //this parameters are 0 if PMU is not declared
    localparam MCCU_DATA_WIDTH = (MCCU!=0)? C_S_AXI_DATA_WIDTH : 0;  
    localparam MCCU_WEIGHTS_WIDTH = (MCCU!=0)?  8 : 0;
    localparam MCCU_N_CORES = (MCCU!=0)? N_CORES : 0;
    localparam MCCU_CORE_EVENTS = (MCCU!=0)? 4: 0;
    //Number of Registers needed to indicate the source of RDC interuption
    localparam MCCU_RDC_REGS = (MCCU==0)? 0 : (MCCU_N_CORES*MCCU_CORE_EVENTS)%
                                          C_S_AXI_DATA_WIDTH > 0 ?
                                          ((MCCU_N_CORES*MCCU_CORE_EVENTS)
                                          /C_S_AXI_DATA_WIDTH) + 1 :
                                          ((MCCU_N_CORES*MCCU_CORE_EVENTS)
                                          /C_S_AXI_DATA_WIDTH);
    //number of registers needed to store weights
    localparam integer MCCU_WEIGHTS_REGS = (MCCU==0) ?
                        0:
                        ((MCCU_N_CORES * MCCU_CORE_EVENTS * MCCU_WEIGHTS_WIDTH)
                        % MCCU_DATA_WIDTH )>0
                        ? 
                        ((MCCU_N_CORES * MCCU_CORE_EVENTS * MCCU_WEIGHTS_WIDTH)
                        / MCCU_DATA_WIDTH) + 1 
                        :
                        ((MCCU_N_CORES * MCCU_CORE_EVENTS * MCCU_WEIGHTS_WIDTH)
                        / MCCU_DATA_WIDTH);
                                     
    localparam MCCU_REGS = (MCCU!=0)? 1 + MCCU_N_CORES + MCCU_N_CORES 
                                        + MCCU_WEIGHTS_REGS + MCCU_RDC_REGS : 0;
    //the outputs of quota_o are read only
    localparam MCCU_R_REGS = (MCCU!=0)? MCCU_N_CORES + MCCU_RDC_REGS : 0;
    //the remaining registers are read write
    localparam MCCU_RW_REGS = (MCCU!=0)? (1 + MCCU_N_CORES + MCCU_WEIGHTS_REGS):0;
    //Base for the read only registers (output quota)   
    localparam BASE_MCCU_R_ONLY = BASE_MCCU + MCCU_RW_REGS;
    //Base for interruption vector Request Duration Counter
    localparam BASE_MCCU_INTRV_RDC = BASE_MCCU_R_ONLY + MCCU_N_CORES;
//----------------------------------------------
//-------------PMU additions local paramaters dependent on MCCU
//----------------------------------------------
    //This may change, there are advantages to be able to set the initial
    //value MCCU output registers are not read only in the strict way. they
    //can be written but they are automatically erased or updated to the right
    //value The same happen with the lower bits of the configuration register
    //of MCCU
    localparam integer R_ONLY_REGS = N_COUNTERS + MCCU_R_REGS;
    //Quota out registers of MCCU are write and read
    localparam integer RW_REGS = N_CONF_REGS + N_OVERFLOW_REGS + N_QUOTA_MASK
                                 + N_QUOTA_LIMIT + MCCU_RW_REGS;
    //Total of memory map registers
    localparam integer TOTAL_REGS = R_ONLY_REGS + RW_REGS;
	// Wire reset and enable signals
//----------------------------------------------
//------------ AXI4LITE signals
//----------------------------------------------
	/* verilator lint_off UNUSED */
    //Lower bits are not used due to 32 bit address aligment
    reg [C_S_AXI_ADDR_WIDTH-1 : 0] 	axi_awaddr;
	/* verilator lint_on UNUSED */
	reg  	axi_awready;
	reg  	axi_wready;
	reg [1 : 0] 	axi_bresp;
	reg  	axi_bvalid;
	/* verilator lint_off UNUSED */
    //Lower bits are not used due to 32 bit address aligment
	reg [C_S_AXI_ADDR_WIDTH-1 : 0] 	axi_araddr;
	/* verilator lint_on UNUSED */
	reg  	axi_arready;
	reg [C_S_AXI_DATA_WIDTH-1 : 0] 	axi_rdata;
	reg [1 : 0] 	axi_rresp;
	reg  	axi_rvalid;

//----------------------------------------------
//-------------MCCU wires
//----------------------------------------------
    //Write back remaining quota in to slv_register allocated for it
    wire [MCCU_DATA_WIDTH-1:0] MCCU_quota_o [ 0: MCCU_N_CORES-1];
    //Interruption to request to Processor to check interruption_vector_rdc
    wire intr_rdc_o;
    assign int_rdc_o = intr_rdc_o;
    //Write back Request Duration Counter (RDC) events in to slv_register 
    //allocated for it. You need to softreset MCCU to clear this vector
    wire [MCCU_CORE_EVENTS-1:0] intrv_rdc_int [0:MCCU_N_CORES-1];
//----------------------------------------------
//-- Signals for user logic register space example
//------------------------------------------------
	//-- Number of Slave Registers 
    reg [C_S_AXI_DATA_WIDTH-1:0] slv_reg [0:TOTAL_REGS-1] /*verilator public*/;
	
    wire	 slv_reg_rden;
	wire	 slv_reg_wren/*verilator public*/;
	reg [C_S_AXI_DATA_WIDTH-1:0]	 reg_data_out;
	integer	 byte_index;
	reg	 aw_en;
//----------------------------------------------
//------------ PMU signals
//----------------------------------------------
    wire en_PMU, rst_PMU;
    //the first bit of the first config register is the enable
    assign en_PMU = slv_reg[N_COUNTERS][0];
    //the second bit of the first config register is the reset
    assign rst_PMU = slv_reg[N_COUNTERS][1];

	// I/O Connections assignments

	assign S_AXI_AWREADY_o	= axi_awready;
	assign S_AXI_WREADY_o	= axi_wready;
	assign S_AXI_BRESP_o	= axi_bresp;
	assign S_AXI_BVALID_o	= axi_bvalid;
	assign S_AXI_ARREADY_o	= axi_arready;
	assign S_AXI_RDATA_o	= axi_rdata;
	assign S_AXI_RRESP_o	= axi_rresp;
	assign S_AXI_RVALID_o	= axi_rvalid;
	// Implement axi_awready generation
	// axi_awready is asserted for one S_AXI_ACLK_i clock cycle when both
	// S_AXI_AWVALID_i and S_AXI_WVALID_i are asserted. axi_awready is
	// de-asserted when reset is low.

	always @( posedge S_AXI_ACLK_i, negedge S_AXI_ARESETN_i)
	begin
	  if ( S_AXI_ARESETN_i == 1'b0 )
	    begin
	      axi_awready <= 1'b0;
	      aw_en <= 1'b1;
	    end 
	  else
	    begin    
	      if (~axi_awready && S_AXI_AWVALID_i && S_AXI_WVALID_i && aw_en)
	        begin
	          // slave is ready to accept write address when 
	          // there is a valid write address and write data
	          // on the write address and data bus. This design 
	          // expects no outstanding transactions. 
	          axi_awready <= 1'b1;
	          aw_en <= 1'b0;
	        end
	        else if (S_AXI_BREADY_i && axi_bvalid)
	            begin
	              aw_en <= 1'b1;
	              axi_awready <= 1'b0;
	            end
	      else           
	        begin
	          axi_awready <= 1'b0;
	        end
	    end 
	end       

	// Implement axi_awaddr latching
	// This process is used to latch the address when both 
	// S_AXI_AWVALID_i and S_AXI_WVALID_i are valid. 

	always @( posedge S_AXI_ACLK_i, negedge S_AXI_ARESETN_i)
	begin
	  if ( S_AXI_ARESETN_i == 1'b0 )
	    begin
	      axi_awaddr <= {C_S_AXI_ADDR_WIDTH{1'b0}};
	    end 
	  else
	    begin    
	      if (~axi_awready && S_AXI_AWVALID_i && S_AXI_WVALID_i && aw_en)
	        begin
	          // Write Address latching 
	          axi_awaddr <= S_AXI_AWADDR_i;
	        end
	    end 
	end       

	// Implement axi_wready generation
	// axi_wready is asserted for one S_AXI_ACLK_i clock cycle when both
	// S_AXI_AWVALID_i and S_AXI_WVALID_i are asserted. axi_wready is 
	// de-asserted when reset is low. 

	always @( posedge S_AXI_ACLK_i, negedge S_AXI_ARESETN_i)
	begin
	  if ( S_AXI_ARESETN_i == 1'b0 )
	    begin
	      axi_wready <= 1'b0;
	    end 
	  else
	    begin    
	      if (~axi_wready && S_AXI_WVALID_i && S_AXI_AWVALID_i && aw_en )
	        begin
	          // slave is ready to accept write data when 
	          // there is a valid write address and write data
	          // on the write address and data bus. This design 
	          // expects no outstanding transactions. 
	          axi_wready <= 1'b1;
	        end
	      else
	        begin
	          axi_wready <= 1'b0;
	        end
	    end 
	end       

	// Implement memory mapped register select and write logic generation
	// The write data is accepted and written to memory mapped registers when
	// axi_awready, S_AXI_WVALID_i, axi_wready and S_AXI_WVALID_i are asserted. Write strobes are used to
	// select byte enables of slave registers while writing.
	// These registers are cleared when reset (active low) is applied.
	// Slave register write enable is asserted when valid address and data are available
	// and the slave is ready to accept the write address and write data.
	assign slv_reg_wren = axi_wready && S_AXI_WVALID_i && axi_awready && S_AXI_AWVALID_i;

	always @( posedge S_AXI_ACLK_i, negedge S_AXI_ARESETN_i )
	begin
	  if ( S_AXI_ARESETN_i == 1'b0 )
	    begin : reset_all
        integer i;
        for (i=N_COUNTERS; i<TOTAL_REGS; i=i+1) slv_reg[i] <={C_S_AXI_DATA_WIDTH{1'b0}};
	    end 
	  else begin
	    if (slv_reg_wren)
	      begin : strobes
            integer i;
            integer write_address;
            /* verilator lint_off WIDTH */
            // Width mismatch between integer 32B and MSB due to aligment of 
            // addresses
            write_address = axi_awaddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB];
            /* verilator lint_on WIDTH */
            
            for (i=N_COUNTERS; i<TOTAL_REGS; i=i+1)begin
                if (write_address == i) begin
                    for ( byte_index = 0; byte_index <= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 )
                      if ( S_AXI_WSTRB_i[byte_index] == 1 ) begin
                        // Respective byte enables are asserted as per write strobes 
                        slv_reg[i][(byte_index*8) +: 8] <= S_AXI_WDATA_i[(byte_index*8) +: 8];
                      end  
                end
            end
	      end else begin
          //here we do the "auto_update" of MCCU variables. Reset overwritten
          //values and update interruption vector
            if(MCCU!=0) begin
                //set the slv_reg of MCCU_quota_o in case someone has
                //overwritten it
                for(integer q=0; q< MCCU_N_CORES-1; q++) begin
                    slv_reg[BASE_MCCU_R_ONLY+q]<=MCCU_quota_o[q];
                end
                //set lower bits of MCCU main configuration back to 0. If this
                //is not reset to 0. MCCU will try to set the quota again and
                //quota will neve decrease. The first bit shall stay enabled
                //and the remaining are masked to 0 
                slv_reg[BASE_MCCU]<=slv_reg[BASE_MCCU] & {1'b1,{C_S_AXI_DATA_WIDTH-1{1'b0}}};
                //Request Duration Counter (RDC) logic. It needs to check if the MCCU
                //generates any interrupt and update the RDC interruption 
                //vector into the slv_register. Map in to slv_reg as in
                //example:
                
                //For 4 cores, 16 signals each, slv_register width 32 bit
                //Core ID, Signal ID, slv_reg     x         , slv_reg bit 
                //0      , 0        , BASE_MCCU_INTRV_RDC   , 0
                //0      , 15       , BASE_MCCU_INTRV_RDC   , 15
                //1      , 0        , BASE_MCCU_INTRV_RDC   , 16
                //1      , 15       , BASE_MCCU_INTRV_RDC   , 31
                //2      , 0        , BASE_MCCU_INTRV_RDC+1 , 0
                
                //TODO: Up to 16 signals per core are supported given the
                //current CDR interruption implementation. Signals per core
                //must be a power of two.
                `ifdef ASSERTIONS
                    assert (MCCU_N_CORES<17);
                    assert ((MCCU_N_CORES==1)  ||
                            (MCCU_N_CORES==2)  ||
                            (MCCU_N_CORES==8)  ||
                            (MCCU_N_CORES==16));
                `endif
                for(integer q=0; q< MCCU_N_CORES*MCCU_CORE_EVENTS; q++) begin
                   /*
                    automatic integer reg_index = (MCCU_N_CORES*MCCU_CORE_EVENTS)
                                        /C_S_AXI_DATA_WIDTH;
                    automatic integer current_slv_reg = BASE_MCCU_INTRV_RDC+reg_index;
                    automatic integer current_slv_bit = q-(reg_index*C_S_AXI_DATA_WIDTH);
                    //TODO: Solve iterators of this loop and check spyglass
                    automatic integer current_intrv_reg = q/MCCU_CORE_EVENTS;
                    automatic integer current_intrv_bit = q-(current_intrv_reg*MCCU_CORE_EVENTS);*/
                    slv_reg [BASE_MCCU_INTRV_RDC][q] <= 
                        intrv_rdc_int[q/MCCU_CORE_EVENTS][q-(q/MCCU_CORE_EVENTS*MCCU_CORE_EVENTS)];
                end
            end
            if(OVERFLOW==1) begin : generated_overflow
            //iterate over the registers, each one has one overflow bit
                    //When more than 32 counters, extra registers are needed
                    `ifdef ASSERTIONS
                        assert(N_COUNTERS < 33);
                    `endif
                for (integer j=0; j<N_COUNTERS; j=j+1) begin : overflow_bit
                    localparam integer OVERFLOW_REGS_OFFSET= N_COUNTERS+N_CONF_REGS;
                    automatic integer a = j/C_S_AXI_DATA_WIDTH;
                        if (rst_PMU) 
                            slv_reg[a+OVERFLOW_REGS_OFFSET]
                            <={C_S_AXI_DATA_WIDTH{1'b0}};
                        else if (slv_reg[j]=={C_S_AXI_DATA_WIDTH{1'b1}})
                                 slv_reg[a+OVERFLOW_REGS_OFFSET][j]<=1'b1;
                end
             end
          end
        end
	end    

	// Implement write response logic generation
	// The write response and response valid signals are asserted by the slave 
	// when axi_wready, S_AXI_WVALID_i, axi_wready and S_AXI_WVALID_i are asserted.  
	// This marks the acceptance of address and indicates the status of 
	// write transaction.

	always @( posedge S_AXI_ACLK_i, negedge S_AXI_ARESETN_i)
	begin
	  if ( S_AXI_ARESETN_i == 1'b0 )
	    begin
	      axi_bvalid  <= 0;
	      axi_bresp   <= 2'b0;
	    end 
	  else
	    begin    
	      if (axi_awready && S_AXI_AWVALID_i && ~axi_bvalid && axi_wready && S_AXI_WVALID_i)
	        begin
	          // indicates a valid write response is available
	          axi_bvalid <= 1'b1;
	          axi_bresp  <= 2'b0; // 'OKAY' response 
	        end                   // work error responses in future
	      else
	        begin
	          if (S_AXI_BREADY_i && axi_bvalid) 
	            //check if bready is asserted while bvalid is high) 
	            //(there is a possibility that bready is always asserted high)   
	            begin
	              axi_bvalid <= 1'b0; 
	            end  
	        end
	    end
	end   

	// Implement axi_arready generation
	// axi_arready is asserted for one S_AXI_ACLK_i clock cycle when
	// S_AXI_ARVALID_i is asserted. axi_awready is 
	// de-asserted when reset (active low) is asserted. 
	// The read address is also latched when S_AXI_ARVALID_i is 
	// asserted. axi_araddr is reset to zero on reset assertion.

	always @( posedge S_AXI_ACLK_i, negedge S_AXI_ARESETN_i )
	begin
	  if ( S_AXI_ARESETN_i == 1'b0 )
	    begin
	      axi_arready <= 1'b0;
	      axi_araddr  <= {C_S_AXI_ADDR_WIDTH{1'b0}};
	    end 
	  else
	    begin    
	      if (~axi_arready && S_AXI_ARVALID_i)
	        begin
	          // indicates that the slave has acceped the valid read address
	          axi_arready <= 1'b1;
	          // Read address latching
	          axi_araddr  <= S_AXI_ARADDR_i;
	        end
	      else
	        begin
	          axi_arready <= 1'b0;
	        end
	    end 
	end       

	// Implement axi_arvalid generation
	// axi_rvalid is asserted for one S_AXI_ACLK_i clock cycle when both 
	// S_AXI_ARVALID_i and axi_arready are asserted. The slave registers 
	// data are available on the axi_rdata bus at this instance. The 
	// assertion of axi_rvalid marks the validity of read data on the 
	// bus and axi_rresp indicates the status of read transaction.axi_rvalid 
	// is deasserted on reset (active low). axi_rresp and axi_rdata are 
	// cleared to zero on reset (active low).  
	always @( posedge S_AXI_ACLK_i, negedge S_AXI_ARESETN_i )
	begin
	  if ( S_AXI_ARESETN_i == 1'b0 )
	    begin
	      axi_rvalid <= 0;
	      axi_rresp  <= 0;
	    end 
	  else
	    begin    
	      if (axi_arready && S_AXI_ARVALID_i && ~axi_rvalid)
	        begin
	          // Valid read data is available at the read data bus
	          axi_rvalid <= 1'b1;
	          axi_rresp  <= 2'b0; // 'OKAY' response
	        end   
	      else if (axi_rvalid && S_AXI_RREADY_i)
	        begin
	          // Read data is accepted by the master
	          axi_rvalid <= 1'b0;
	        end                
	    end
	end    

	// Implement memory mapped register select and read logic generation
	// Slave register read enable is asserted when valid address is available
	// and the slave is ready to accept the read address.
	assign slv_reg_rden = axi_arready & S_AXI_ARVALID_i & ~axi_rvalid;
	always @(*)
	begin :decode_read
	      // Address decoding for reading registers
	      integer i;
          // Address read as integer to avoid width mismatch
          integer read_address;
          /* verilator lint_off WIDTH */
          read_address = axi_araddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB];
          /* verilator lint_on WIDTH */
          
          reg_data_out ={C_S_AXI_DATA_WIDTH{1'b0}};
          //check if the address is out of the range of R registers
          if(read_address > 0 && read_address < TOTAL_REGS) begin
              for (i=0; i<TOTAL_REGS; i=i+1) begin
                if (read_address==i) begin
                    //TODO: I think W415a is alright here. There is a better
                    //way to do it?
                    reg_data_out =slv_reg[i];
                end
              end
          end
    end
	// Output register or memory read data
	always @( posedge S_AXI_ACLK_i, negedge S_AXI_ARESETN_i )
	begin
	  if ( S_AXI_ARESETN_i == 1'b0 )
	    begin
	      axi_rdata  <= 0;
	    end 
	  else
	    begin    
	      // When there is a valid read address (S_AXI_ARVALID_i) with 
	      // acceptance of read address by the slave (axi_arready), 
	      // output the read dada 
	      if (slv_reg_rden)
	        begin
	          axi_rdata <= reg_data_out;     // register read data
	        end   
	    end
	end    

   
//-------------Adders with reset
    //Inside the generate loop it creates as many counters as the parameter
    //N_COUNTERS. For each of them one slv_reg is assigned. When a soft reset
    //(rst_PMU high) or hard reset (S_AXI_ARESETN_i) slv_registers are set
    //to 0. If non of this cases happen if the PMU is enabled (en_PMU high) and
    //the event of the given counter (events_i[k]) is high the counter
    // increases by one.
    genvar k;
    generate
    for (k=0; k<N_COUNTERS; k=k+1) begin : generated_counter
        always @(posedge S_AXI_ACLK_i, negedge S_AXI_ARESETN_i) begin
            if(!S_AXI_ARESETN_i)
                slv_reg[k] <={C_S_AXI_DATA_WIDTH{1'b0}};
            else begin
                if(rst_PMU) slv_reg[k] <={C_S_AXI_DATA_WIDTH{1'b0}};
                else if(events_i[k] & en_PMU) slv_reg[k] <= slv_reg[k]+1;
            end
        end
    end
    endgenerate
//-------------Overflow
//TODO:
//this one may not be parametric if more than 32 counters are used
    //Here we generate the overflow signal for each one of the counters. 
    //One bit per counter is given in the overflow register. a accounts for
    //multiple 32 bit registers if needed.(slv_reg[a+OVERFLOW_REGS_OFFSET])
    //Overflow registers are placed after Counter and Configuration registers.
    //At hard or soft reset values are set to 0. 
    if(OVERFLOW==1) begin : generated_int_overflow
        always@(*) begin
                //TODO:multiple assigments (W415a) seems safe here 
                int_overflow_o = 0;
            //iterate over the registers, each one has one overflow bit
                for (integer j=0; j<N_COUNTERS; j=j+1) begin : overflow_bit
                    //When more than 32 counters, extra registers are needed
                    automatic integer OVERFLOW_REGS_OFFSET= N_COUNTERS+N_CONF_REGS;
                    automatic integer a = j/C_S_AXI_DATA_WIDTH;
                    int_overflow_o =(rst_PMU || (S_AXI_ARESETN_i == 1'b0))?
                                         1'b0: | slv_reg[a+OVERFLOW_REGS_OFFSET];
                end
            //decide the overflow register if there are more than 32 counters
            //if overflow set bit to 1
        end
    end else assign int_overflow_o = 1'b0;

//-------------Quota
    //TODO
    //instead of sum the 16 registers at the same time you could use a 
    //statemachine that sums two at a time. you will increase latency but less
    //hardware is required
    //64 bits for overflow are not needed

    //A quota consumption interruption is generated when a the total of 
    //measured events exceeds the value set in slv_reg[BASE_QUOTA+1].
    //To account for a given event a 1 must be set to the correspondent bit in
    //slv_reg[BASE_QUOTA][x]. (This register is refered as Quota mask)
    //When the mask is 0 the value is not accounted for the quota.
    //If the QUOTA local parameter is set to 0, int_quota_o will never trigger.
    genvar x;
    generate
        if(QUOTA==1) begin : generated_quota
            //from each register we take a wire 
            wire [C_S_AXI_DATA_WIDTH-1:0] values_count [0:N_COUNTERS-1];
            reg [63:0]suma;//64bits to avoid overflows
            longint tmp;
            for (x=0; x<N_COUNTERS; x=x+1) begin : check_mask
                //when reset is eneabled the values are 0. If not reset
                // check the mask and pass the value of the counter if enabled
                assign values_count[x]=
                        (rst_PMU || (S_AXI_ARESETN_i == 1'b0))
                        ?{C_S_AXI_DATA_WIDTH{1'b0}}:
                        {C_S_AXI_DATA_WIDTH{slv_reg[BASE_QUOTA][x]}}
                        &slv_reg[x];
            end
            //avoid width mismatch when dealing with 32b register addition
            localparam padding0 = 64-C_S_AXI_DATA_WIDTH;
            assign int_quota_o =(suma>{{padding0{1'b0}},slv_reg[BASE_QUOTA+1]})
                                ? 1'b1:1'b0;
            //Add quotas of all signals. The ones that are not enabled are 0
            integer y;
            //TODO: why I cant use the same genvar X. Instead of y?
            always @(*) begin
                    tmp =0;
                    for(y=0; y<N_COUNTERS; y=y+1)  begin: sum_quotas
                       tmp={{padding0{1'b0}},values_count[y]}+tmp;
                    end
                    suma=tmp;
            end
        end else assign int_quota_o =1'b0;
    endgenerate

//-------------MCCU instance and auxiliar logic
        //max cores == MCCU_DATA_WIDTH -1
    if(MCCU !=0) begin : generate_MCCU
        wire [MCCU_CORE_EVENTS-1:0] events_int [0:MCCU_N_CORES-1];
        wire MCCU_enable_int;
        wire MCCU_update_quota_int [0:MCCU_N_CORES-1];
        
        //first n bits (MCCU_N_CORES) set when the quota need to be updated.
        //The update_quota_int needs to be  reset after one cycle. IF
            // not the counter will not decrease.
            // This module maps the bits of the slave registers to the unpack wire
            // that connects with the MCCU to trigger an update of the quota
            //The update only at rise can be done here with some temporal
            //registers that check when the slv_register as changed, but it
            //will need to check as well if there is a new write every time,
            //not only the changes in slv_reg. I have prefered to reset the
            //lower bits of slv_reg[BASE_MCCU] to 0 every time the register is
            //not written. To prevent problems with multidriven signals we
            //shall check the AXI_LITE state machines
            
            //Addres where the  base configuration register is located
            //current write address
        genvar i; 
        for (i=0;i<MCCU_N_CORES;i=i+1) begin
            assign MCCU_update_quota_int[i] = slv_reg[BASE_MCCU][i];
        end 
        //last bit of the  first register in the MCCU region is the enable
        assign MCCU_enable_int = slv_reg[BASE_MCCU][MCCU_DATA_WIDTH-1];
        //penultimate bit of the  first register in the MCCU region does soft 
        //reset of MCCU registers
        wire MCCU_rstn_int; 
        assign MCCU_rstn_int = ~slv_reg[BASE_MCCU][MCCU_DATA_WIDTH-2];
        //Map interesting signals to MCCU
        //TODO: Each new instance needs to be tweaked here. Depending on the
        //SOC you may want to route the signals differently for events_int
        for(i = 0; i<MCCU_N_CORES; i++) begin
            assign events_int[i] = {
                                    events_i[0+i]
                                    ,events_i[1+i]
                                    ,events_i[2+i]
                                    ,events_i[3+i]
            };
        end
       
        
        //Map slv_regs that control the quota in to the MCCCU
        wire [MCCU_DATA_WIDTH-1:0] MCCU_quota_int [ 0: MCCU_N_CORES-1];
        //TODO: this is not parametric. if more than one config register is
        //needed for MCCU this need to be changed. Parametrize this in the
        //futute
        localparam OFFSET_MCCU_CONFIG = 1;
        for (i=0;i<MCCU_N_CORES;i=i+1) begin
            assign MCCU_quota_int[i] = slv_reg[BASE_MCCU + 
                                                      OFFSET_MCCU_CONFIG+i];
        end 
         
        //map slv_reg s to events_weights_i. Weight size shall be a power of
        //2 an smaller than MCCU_DATA_WIDTH. This constrain can be overcome
        //with a mechanism "align" the weights of the registers in hardware but
        `ifdef ASSERTIONS
             //we will skip it for now And assume that MCCU_DATA_WIDTH is
             //always aligned
             //TODO: handele misaligment aligments and remove this constrains 
            always@(*) begin
            assert (
                    (MCCU_DATA_WIDTH!=4) 
                    ||(MCCU_DATA_WIDTH!=8) 
                    || (MCCU_DATA_WIDTH!=16) 
                    || (MCCU_DATA_WIDTH!=32);
            end
        `endif
        
        //Nº of the slv_register where weights start
        localparam OFFSET_MCCU_WEIGHTS = OFFSET_MCCU_CONFIG + MCCU_N_CORES;
        //Nº of bits required to store all weights
        localparam TOTAL_WEIGHT_BITS = MCCU_CORE_EVENTS * MCCU_N_CORES
                                       * MCCU_WEIGHTS_WIDTH; 
        //Single wire array with the values of the weights
        wire [TOTAL_WEIGHT_BITS-1:0] weights_flat_bitarray;
        for (i=0;i<MCCU_CORE_EVENTS*MCCU_N_CORES;i=i+1) begin : slv_reg_to_flat_bitarray
            //Track the Nº of bits used by the weight registers until this
            //iteration of the loop
            localparam USED_BITS = (i+1)*MCCU_WEIGHTS_WIDTH;
            //Track the Nº of registers that weights ocuppy based on DATA_WIDTH
            //WEIGHTS_WIDTH and iteration
            localparam USED_REGISTERS = ((USED_BITS % MCCU_DATA_WIDTH)>0) ?
                                        USED_BITS/MCCU_DATA_WIDTH+1 : 
                                        USED_BITS/MCCU_DATA_WIDTH;
            //Rename local parameter for clarify  assignation
            localparam CURRENT_REG_OFFSET = USED_REGISTERS; 
            //Offset of the weights you are assigning in  this iteration for
            //the weights_flat_bitarray. 
            localparam ARRAY_BIT_OFFSET_H = USED_BITS-1;
            localparam ARRAY_BIT_OFFSET_L = (USED_BITS
                                            -MCCU_WEIGHTS_WIDTH);
            
            //If ARRAY_BIT_OFFSET_H exceeds the first slv_reg size we have
            //to wrap the indexes.
            localparam int SLV_BIT_OFFSET_H = ARRAY_BIT_OFFSET_H 
                                                % MCCU_DATA_WIDTH; 
            localparam int SLV_BIT_OFFSET_L = ARRAY_BIT_OFFSET_L 
                                                % MCCU_DATA_WIDTH;
            `ifdef ASSERTIONS
            always@(*) begin
                // If the registers can not fit one weigth this design is not
                // valid
                assert(MCCU_DATA_WIDTH>=MCCU_WEIGHTS_WIDTH);
                assert(SLV_BIT_OFFSET_H>SLV_BIT_OFFSET_L);
                //right now the weights shall be always aligned
            end
            `endif
            //If weight is not misaligned
            if(SLV_BIT_OFFSET_H>SLV_BIT_OFFSET_L) begin : aligned_weight
                assign weights_flat_bitarray[ARRAY_BIT_OFFSET_H
                                            :ARRAY_BIT_OFFSET_L]
                                            =
                                            slv_reg [CURRENT_REG_OFFSET 
                                            + BASE_MCCU + N_CORES]
                                           [SLV_BIT_OFFSET_H:SLV_BIT_OFFSET_L];
            end 
        end 
        //rearrange weights to match events_weights_i
        wire [MCCU_WEIGHTS_WIDTH-1:0] MCCU_events_weights_int [0:MCCU_N_CORES-1]
                                                       [0:MCCU_CORE_EVENTS-1];
        //genvar x;
        for(x=0;x<MCCU_N_CORES;x++) begin
            genvar y;
            for(y=0;y<MCCU_CORE_EVENTS;y++) begin
                //calculate the indexes in the flat bitarray
                localparam LOW_INDEX = (x*MCCU_CORE_EVENTS*MCCU_WEIGHTS_WIDTH)+(y*MCCU_WEIGHTS_WIDTH);
                localparam HIGH_INDEX = (((x*MCCU_CORE_EVENTS*MCCU_WEIGHTS_WIDTH)+((y+1)*MCCU_WEIGHTS_WIDTH))-1);
                assign MCCU_events_weights_int [x][y] = weights_flat_bitarray
                                                        [HIGH_INDEX:LOW_INDEX]; 
            end
        end
        MCCU # (
            // Width of data registers
            .DATA_WIDTH     (MCCU_DATA_WIDTH),
            // Width of weights registers
            .WEIGHTS_WIDTH  (MCCU_WEIGHTS_WIDTH),
            //Cores. Change this may break Verilator TB
            .N_CORES        (MCCU_N_CORES),
            //Signals per core. Change this may break Verilator TB
            .CORE_EVENTS    (MCCU_CORE_EVENTS)
        )
        inst_MCCU(
            .clk_i                  (S_AXI_ACLK_i),
            .rstn_i                 (S_AXI_ARESETN_i || MCCU_rstn_int),
            .enable_i               (MCCU_enable_int),// Software map
            .events_i               (events_int),//how to parametrize this? new parameter on top or up to the programer that does the integration?
            .quota_i                (MCCU_quota_int),//One register per core
            .update_quota_i         (MCCU_update_quota_int),//Software map
            .quota_o                (MCCU_quota_o),//write back to a read register
            .events_weights_i       (MCCU_events_weights_int),//core_events times WEIGHTS_WIDTH registers
            .interruption_quota_o   (MCCU_int_o)//N_CORES output signals Add this to top or single toplevel interrupt and an interrupt vector that identifies the source?
                                       // Individual interrupts allow each core to
                                       // handle their own interrupts , therefore
                                       //it seems to be te right solution.
        );

        //Request Duration Counter (RDC)
        //TODO: events_int is not the group of signals you actually need
        RCD #(
            // Width of data registers
            .DATA_WIDTH     (MCCU_DATA_WIDTH),
            // Width of weights registers
            .WEIGHTS_WIDTH  (MCCU_WEIGHTS_WIDTH),
            //Cores. 
            .N_CORES        (MCCU_N_CORES),
            //Signals per core. 
            .CORE_EVENTS    (MCCU_CORE_EVENTS)
        ) inst_RCD(
            .clk_i                  (S_AXI_ACLK_i),
            .rstn_i                 (S_AXI_ARESETN_i || MCCU_rstn_int ),
            .enable_i               (MCCU_enable_int),// Software map
            .events_i               (events_int),//how to parametrize this? new parameter on top or up to the programer that does the integration?
            .events_weights_i       (MCCU_events_weights_int),//core_events times WEIGHTS_WIDTH registers
            .interruption_rdc_o(intr_rdc_o),// interruption signaling a signal has exceed the expected maximum request time
            .interruption_vector_rdc_o(intrv_rdc_int) // vector with offending
                //signals. One hot encoding.
                //Cleared when MCCU is disabled.
        );
    end else begin
        //TODO: what happen if i is an integer instead of a genvar?
        genvar i;
        //drive interrupts to 0 if no MCCU to prevent problems
        for (i=0;i<MCCU_N_CORES;i=i+1) begin
            assign MCCU_int_o[i] = 1'b0;
        end
    end
////////////////////////////////////////////////////////////////////////////////
//
// Formal Verification section begins here.
//
////////////////////////////////////////////////////////////////////////////////
`ifdef	FORMAL
localparam	F_LGDEPTH = 4;

	wire	[(F_LGDEPTH-1):0]	f_axi_awr_outstanding,
					f_axi_wr_outstanding,
					f_axi_rd_outstanding;
	// Connect our slave to the AXI-lite property set
	//
	faxil_slave #(  .C_AXI_DATA_WIDTH(C_S_AXI_DATA_WIDTH),
			.C_AXI_ADDR_WIDTH(C_S_AXI_ADDR_WIDTH),
			.F_LGDEPTH(F_LGDEPTH)) properties(
		.i_clk(S_AXI_ACLK_i),
		.i_axi_reset_n(S_AXI_ARESETN_i),
		//
		.i_axi_awaddr(S_AXI_AWADDR_i),
		.i_axi_awcache(4'h0),
		.i_axi_awprot(1'b0),
		.i_axi_awvalid(S_AXI_AWVALID_i),
		.i_axi_awready(S_AXI_AWREADY_o),
		//
		.i_axi_wdata(S_AXI_WDATA_i),
		.i_axi_wstrb(S_AXI_WSTRB_i),
		.i_axi_wvalid(S_AXI_WVALID_i),
		.i_axi_wready(S_AXI_WREADY_o),
		//
		.i_axi_bresp(S_AXI_BRESP_o),
		.i_axi_bvalid(S_AXI_BVALID_o),
		.i_axi_bready(S_AXI_BREADY_i),
		//
		.i_axi_araddr(S_AXI_ARADDR_i),
		.i_axi_arprot(1'b0),
		.i_axi_arcache(4'h0),
		.i_axi_arvalid(S_AXI_ARVALID_i),
		.i_axi_arready(S_AXI_ARREADY_o),
		//
		.i_axi_rdata(S_AXI_RDATA_o),
		.i_axi_rresp(S_AXI_RRESP_o),
		.i_axi_rvalid(S_AXI_RVALID_o),
		.i_axi_rready(S_AXI_RREADY_i),
		//
		.f_axi_rd_outstanding(f_axi_rd_outstanding),
		.f_axi_wr_outstanding(f_axi_wr_outstanding),
		.f_axi_awr_outstanding(f_axi_awr_outstanding));
`endif

endmodule

`default_nettype wire //allow compatibility with legacy code and xilinx ip

